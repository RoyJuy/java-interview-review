### 事务的四个特性：

##### 原子性（Atomicity）

事务包含的所有操作要么全部成功，要么全部失败，因此事务的操作如果成功就必须完全应用到数据库，如果操作失败则不能对数据库有任何影响

##### 一致性（Consistency）

事务必须是数据库从一个一致性的状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

##### 隔离性（Isolation）

当多个用户并发访问数据库时，同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作干扰，多个并发事务之前要相互隔离。

##### 持久性（Durability）

事务一但被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### 事务的隔离级别：

由低到高的顺序

1. ##### Read uncommitted(未授权读取，读未提交)

   如果一个事物已经开始写数据，则另一个事务则不允许同事进行写操作，但允许其他事物读此行数据。该隔离级别可以通过“排他写锁”实现。**避免更新丢失，但可能出现脏读**

2. ##### Read committed(授权读取，读已提交)

   读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事物访问该行。该隔离级别避免了脏读，**但是可能出现不可重复读**。

3. ##### Repeatable read(可重复度)

   可重复读是指在一个食物内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问了该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的数据是一样的。这样就发上了在一个事务内两次读到的数据是一致的，因此称为可重复读。读取数据的事务将禁止些事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但可能出现幻读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。

4. ##### Serializable(序列化)

   提供严格的事务隔离。他要求事务序列化执行，事务只能一个接着一个执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新的插入数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代驾也花费最高，性能很低，一般很少使用，该级别下，事务顺序执行，可以避免脏读，不可重复读和幻读

| 隔离级别         | 脏读 | 不可重复度 | 幻读 | 第一类丢失更新 | 第二类丢更新 |
| ---------------- | ---- | ---------- | ---- | -------------- | ------------ |
| Read uncommitted | √    | √          | √    | ×              | √            |
| Read committed   | ×    | √          | √    | ×              | √            |
| Repeatable read  | ×    | ×          | √    | ×              | ×            |
| Serializable     | ×    | ×          | ×    | ×              | ×            |

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也大。对于多数应用程序，可以优先考虑把数据库系统的级别设为read committed。它能避免脏读，而且具有较好的并发性能。尽管它会导致不可重复读，幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁。大多数数据库的默认级别就是Read committed，比如sql server, oracle. mysql的默认隔离级别是Repeatable read。