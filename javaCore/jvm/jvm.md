# 一、运行时数据区域

![](https://raw.githubusercontent.com/RoyJuy/imags/master/img/20200911160405.png)

## 程序计数器

记录正在执行的虚拟机字节码指令的地址。如果正在执行的是本地方法则为空

## java虚拟机栈

每个java方法在执行的时候都会创建一个栈帧用于存储，局部变量，操作数栈和常量池引用等信息。

**<u>*-Xss*</u>**参数可以指定每个线程的java虚拟机栈内存大小

```java
java -Xss2M
```

可能会抛出的异常

- StackOverflowError : 当线程栈请求的栈深度超过最大值
- OutOfMemoryError : 栈进行动态拓展的时候如果无法申请到足够的内存

## 本地方法栈

于java虚拟机栈类似。他们的区别是本地方法栈是为本地方法服务的。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

------



## 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（GC堆）

现代的垃圾收集器基本都是采用的分代收集算法，其主要思想是针对不同的类型的对象采用不同垃圾回收算法。可以分为：

- 新生代（Young Generation）
- 老年代（Old Generation）

堆不需要连续内存，并且可以动态的增加内存，增加失败会报OutOfMemoryError

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

## 方法区

用于存放已经被加载的类信息、常量、静态变量和即时编译器编译后的代码等数据

和堆一样不需要连续内存，并且可以动态扩展，扩展失败也会报OutOfMemoryError

对这块区域进行垃圾回收的主要目标是对常量吃的回收和对类的卸载，但是一般比较难实现

HotSpot虚拟机把他当成永久代来进行垃圾回收。但很难确定永久代的大小，因为受很多因素影响，并且每次 full gc 后永久代的大小都会变化，所以会经常抛OutOfMemoryError 为了容易管理方法区，从jdk1.8开始，移除了永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中

方法区是一个jvm规范，永久代和元空间都是一种实现方式。在jdk1.8之后，原来的永久代数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量等放入堆中。

## 运行时常量

运行时常量池是方法区的一部分。

class文件中常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域

除了在编译时期的生成的常量，还允许动态生成，类如String类的intern()

## 直接内存

在jdk1.4新引入的NIO类，它可以使用Native函数库直接分配堆外内存，然后通过java堆里DirectByteBuffer对象作为这块内存的引用进行操作

这样能在一些场景中显著提升，因为避免了在堆内存和堆外内存来回拷贝数据



# 二、垃圾收集

垃圾收集主要是针对堆和方法区进行的，程序计数器、java虚拟机栈和本地方法栈属于线程私有的，只存在于线程的生命周期内，线程结束后就会消失，因此不需要对这块进行垃圾回收

### 判断一个对象是否可以被回收

1. 引用计数算法
2. 可达性分析算法

### 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低的多，所以在方法区上进行回收的性价比不高

主要是对常量池的回收和类的卸载

为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能

类的卸载条件很多，需要满足以下条件，并且满足了条件也不一定会卸载

- 该类的所有实例都被回收，此时堆中不存在该类的任何实例
- 加载该类的classLoader已经被回收
- 该类对应的class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法

### finalize()

类似c++的析构函数，用于关闭外部资源。但是try-finally等方式可以做的更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，结果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法

### 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

四种强度不同的引用类型。

1. 强引用

被强引用关联的对象不会被回收

使用new一个新对象的方式来创建强引用

```java
Object obj = new Object();
```

2. 软引用

被软引用的对象只有在内存不够的情况下才会被回收

使用SoftReference类来创建软引用

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftRefernce<Object>(obj);
obj = null; // 使对象只被软引用关联
```

3. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只存活到下一次垃圾回收发生之前。

使用WeakReference类来创建弱引用

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

