### 死锁

两个或两个以上的线程在执行过程中，由于竞争资源或者互相通信造成阻塞现象，若无外力作用，他们都讲无法将程序进行下去。

条件：T表示任务，S表示资源

1. 不可剥夺条件：T1拥有的条件无法被T2获取
2. 请求与保持条件：T1拥有S1的同时，请求S2的资源，但是不能立即获得
3. 互斥条件：同一时间同一资源只能被一个任务所获取使用
4. 循环等待条件：若干线程之间形成一种头尾相连的循环等待条件

### 共享锁

S锁/读锁，能查看但无法修改和删除的一种数据锁，加锁后其他用户可以并发读取，查询数据，但不能修改，删除，增加数据，读锁可以被多个线程所持有，<u>**用于资源数据共享**</u>

### 互斥锁

X锁/排他锁/写锁/独占锁，该锁每一次只能被一个线程所占有，加锁后任何线程试图再次加锁的线程会被阻塞，知道当前线程解锁

### 可重入锁

递归锁，在外层使用锁之后，在内层仍可使用，并且不会发生死锁

### 不可重入锁

若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞

### 自旋锁

一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断判断是否能够成功获取到锁，直到成功获取到锁才会退出循环，任何时刻最多只能由一个执行单元能够获取到锁

自旋锁不会线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是会消耗CPU资源

### 公平锁

多个线程按照申请锁的顺序来获取锁。如果一个线程组里，保证每个线程都能拿到锁比如ReentrantLock(公平锁的实现是同步队列FIFO来实现的)

### 非公平锁

获取锁的顺序是随机的，不能保证每个线层都能获取到锁，也就会存在有线程饿死，一直拿不到锁，比如synchronized, ReentrantLock(非公平锁的实现)

### 悲观锁

当线程去操作数据库的时候，总认为别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized

### 乐观锁

当线程去操作数据库的时候，认为逼得线程不会修改数据，更新的数据的时候会判断别人是否会去修改数据，通过版本判断，如果数据被修改了就会拒绝更新，比如CAS是乐观锁，但严格来说并不是锁，通过原子性来保证数据的同步，比如数据库的乐观锁，通过版本来控制，但是CAS不会保证线程同步，乐观的认为在数据更新期间不会有别的线程影响

------



### 分段锁

是一种锁设计，并不是具体的哪一种锁，对ConcurrentHashMap来说，其并发的实现就是通过分段锁的形式来实现高效的并发操作，ConcurrentHashMap中的分段锁称为Segment，类似于hashMap的结构，内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock(Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashMap加锁，而是先通过hashCode来知道要放在哪一个分段中，然后对这个分段进行加锁，所以当线程put的时候，只要不是放在一个分段中，就可以实现并发插入。但是在统计size的时候，可就是获取hashMap的全局信息的时候，就需要获取所有的分段锁进行统计

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作



### 表锁、行锁

------



<u>偏向锁，轻量级锁和重量级锁</u>是JVM是为了提高锁的获取与释放而做的优化，针对synchronized的锁升级，锁的状态是通过对象监视器在对象头的字段表明，是不可逆的过程



### 偏向锁

一段同步代码一直被一个线程访问，那么该线程会自定获取锁，获取锁的代价更低，性能更高

### 轻量级锁

当锁是偏向锁时，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式去尝试获取锁，线程不会阻塞，性能更高

### 重量级锁

当锁是轻量级锁的时候，其他线程虽然是自旋转，但是自旋不会一直循环下去，当自旋一定次数的时候还没有获取到锁，就会进入到阻塞状态，该锁升级为重量级锁，重量级锁会让请他申请的线程进入阻塞，性能也会降低

